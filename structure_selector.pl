#!/usr/bin/env perl
#@ Yulong Li <liyulong12@mails.ucas.ac.cn>
# version 2019.10.25
use strict;
use warnings;
use lib "./pod";
use struct_parser;
use POSIX;
use List::MoreUtils qw{uniq};
use Storable;
use Getopt::Long;
use Sort::Key::Natural qw( natsort );
use constant V    => '191025';
my ($in_path, $files, $multi, $out, $admix, $popmap, $choose, $ma, $logs, $help, @summary);
my $rm       = 'med';
my $out_path = './';
my $thred    = 0.5;
GetOptions (
            "in=s"      =>\$in_path,
            "th=s"      =>\$thred,
            "out=s"     =>\$out_path,
            "multi:1"   =>\$multi,
            "remove:s"  =>\$rm,
            "name=s"    =>\$out,
            "admix:1"   =>\$admix,
            "popmap=s"  =>\$popmap,
            "choose:1"  =>\$choose,
            "logs:1"    =>\$logs,
            "help:1"    =>\$help
            ) or die "$!";
my $usage = q{
    Options [default values]:
        
    -i: path for the input files.
    -t: thredsholds for Puechmaille method[0.5]. split by ; if you want multi values, e.g. 0.5;0.6;0.7
    -o: output path.
    -m: input path contains multi datasets?[0].
    -n: prefix name for the output files.
    -a: input format is admixture or Q-matrix[0]? Default is structure.
    -c: apply chooseK algorithm?
    -l: parse logs for fastStructure or ADMIXTURE.
    -p: group option, popmap files, see examples(can also be e.g. 20,20,20).
    -r: remove ghost method, 'avg' or 'med'.
    -h: help.
};

die $usage unless ($in_path&&$thred&&!$help);        
my $out_fh;
my @thred   = split(/;/, $thred); # array for thredsholds.
my $localtime = localtime;
my $medk_head ='# Generated by StructureSelector
# http://lmme.qdio.ac.cn/StructureSelector/
# https://lmme.ac.cn/StructureSelector/        
# Contact: Yulong Li <liyulong12@mails.ucas.ac.cn>
# Citation: Li YL, Liu JX (2018) StructureSelector: A web based software to select and visualize the optimal number of 
# clusters using multiple methods.Molecular Ecology Resources, 18:176–177.
#
# Puechmaille Method:
# Citation:
# Puechmaille SJ (2016) The program structure does not reliably recover the correct population structure 
# when sampling is uneven: subsampling and new estimators alleviate the problem. Molecular Ecology Resources, 16: 608-627.' . "\n";

my $delta_head = '# Generated by StructureSelector
# http://lmme.qdio.ac.cn/StructureSelector/
# https://lmme.ac.cn/StructureSelector/    
# Contact: Yulong Li <liyulong12@mails.ucas.ac.cn>
# Citation: Li YL, Liu JX (2018) StructureSelector: A web based software to select and visualize the optimal number of 
# clusters using multiple methods.Molecular Ecology Resources, 18:176–177.
#
# Evanno method:
# Citation:
# Evanno G, Regnaut S, Goudet J (2005) Detecting the number of clusters of individuals using the software structure: 
# a simulation study. Molecular Ecology, 14: 2611-2620.
# K    Reps    Mean LnP(K)    Stdev LnP(K)    Ln\'(K)    |Ln\'\'(K)|    Delta K' . "\n";
my $pi_head = q{# Generated by StructureSelector
# http://lmme.qdio.ac.cn/StructureSelector/
# https://lmme.ac.cn/StructureSelector/
# Contact: Yulong Li <liyulong12@mails.ucas.ac.cn>
# Citation: Li YL, Liu JX (2018) StructureSelector: A web based software to select and visualize the optimal number of
# clusters using multiple methods.Molecular Ecology Resources, 18:176–177.
#
# Parsimony method:
# Citation:
# Wang J., (2019) A parsimony estimator of the number of populations from
# a STRUCTURE‐like analysis. Molecular Ecology Resources, 19:970–981.
} . join("\t", '#K', 'Reps', 'Nr', 'SPS', 'SPS*', 'PI') ."\n";

eval { &main() }; # try catch.
if ($@) {
    
    print STDERR "Error: $@\n";
    
    my $rindex = rindex($@, " at");
    my $errMsg = substr($@, 0, $rindex);
    open(my $oh, ">>$out_path/error.OU") or die "$!";
    print $oh $errMsg;
    close $oh;
    exit;
}
sub main {
if ($multi) {
    
    batch($in_path, \@thred, $popmap);
    
} else {
    
    if ($admix) {
        
        my ($files, $batch) = parse_flst($in_path, 'admix', 1) if not defined $files;
        
        my @logs    = @{struct_parser::parse_f($in_path, '.log')};
        $logs = 0 if scalar(@logs) ne scalar(@$files);
        my ($ma, $ll, $reps) = calc_admix($files, $in_path, $popmap, \@thred, $out, $logs);
        
        pr_likelihood($ll, $reps, $out_path, $out) if ($logs && $ll);
        
        if ($choose) {
            chooseK($in_path, $out_path, $out, $ma, $ll);
        }
    } else {
        my $flag = 1;
        my ($files, $batch) = parse_flst($in_path, 'struct', 1) if not defined $files;
        my $ma = calc_str($files, $in_path, \@thred, $out, $flag, $popmap);
        if ($choose) {
            chooseK($in_path, $out_path, $out, $ma);
        }
    }
}
}
sub batch {
    
    my $in_path = shift;
    my $thred   = shift;
    my $popmap  = shift;
    
    if ($admix) {
    
        my ($flst, $batch) = parse_flst($in_path, 'admix');
        if ($batch == 1) {
            #
            # batch files in different folders.
            # files in different folders!
            #
            foreach my $dir (@$flst) {
                my ($files, $tmp) = parse_flst("$in_path/$dir", 'admix', 1);
                $ma = calc_admix($files, "$in_path/$dir", $popmap, $thred, $dir);
                chooseK("$in_path/$dir", $out_path, $dir, $ma);
                
            }
        
        } else {
            #
            # make sub folders first
            #
            $flst = $flst->{'q'};
            foreach my $name (keys %$flst) {
                #
                # each sub dir.
                #
                mkdir("$in_path/$name");
                my @files;
                foreach my $run (keys %{$flst->{$name}}) {
                    my $file = $flst->{$name}->{$run};
                    `mv $in_path/$file $in_path/$name/`;
                    push @files, $file;
                }
                $ma = calc_admix(\@files, "$in_path/$name", $popmap, $thred, $name);
                chooseK("$in_path/$name", $out_path, $name, $ma);
            }
        }
        
    } else {
        #
        # Structure format.
        #
        my ($flst, $batch) = parse_flst($in_path, 'struct');
        if ($batch == 1) {
            #
            # batch files in different folders.
            #
            foreach my $dir (@$flst) {
                my $flag = 1;
                my $ma;
                my ($files, $tmp) = parse_flst("$in_path/$dir", 'struct', 1);
                $ma = calc_str($files, "$in_path/$dir", $thred, $dir, $flag, $popmap);
                $flag = 0;
                chooseK("$in_path/$dir", $out_path, $dir, $ma);
            }
        
        } else {
            #
            # make sub folders first
            #
            $flst = $flst->{'f'};
            foreach my $name (keys %$flst) {
                my @files;
                mkdir("$in_path/$name");
                foreach my $run (keys %{$flst->{$name}}) {
                    my $file = $flst->{$name}->{$run};
                    `mv $in_path/$file $in_path/$name/`;
                    push @files, $file;
                }
                my $flag = 1;
                $ma = calc_str(\@files, "$in_path/$name", $thred, $name, $flag, $popmap);
                $flag = 0;
                chooseK("$in_path/$name", $out_path, $name, $ma);
            }
        }
    }
    #return $ma; # return Q-matrix.
}

sub calc_admix {
    #
    #
    #
    my $files   = shift;
    my $in_path = shift;
    my $pop     = shift;
    my $thred   = shift;
    my $dir     = shift;
    my @thred   = @$thred;
    my $flag    = shift; # flag for get log files.
    my $reps;
    #
    # Admixture format.
    #
    my ($clsts, $K, $file, $pops, $ma, $ll,$sum, $qtable) = struct_parser::parse_admix($files, $in_path, $pop, $out_path, $flag);
    my @K = @{$K};
    $dir .= $dir ? '.' : '';
    foreach$thred (@thred) {
        my ($med, $medk, $iter) = struct_parser::calc_medk($clsts, $thred, $K);
        my @medmed  = @{$med->{'medmed'}};
        my @medmean = @{$med->{'medmean'}};
        my @maxmed  = @{$med->{'maxmed'}};
        my @maxmean = @{$med->{'maxmean'}};
        
        #
        # Output results....
        #
        
        #print header.
        open($out_fh, ">$out_path/${dir}MedK.$thred.tsv") or die "$!";
        my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
        print $out_fh "# File generated at $ltime\n";
        print $out_fh $medk_head;
        print $out_fh join("\t", 'K', 'MedMed', 'MedMean', 'MaxMed', 'MaxMean', 'Reps'), "\n";
        
        for (my $i=0; $i<@K; ++$i) {
            
            my $k = $K[$i];
            print $out_fh join("\t", $k, $medmed[$i], $medmean[$i], $maxmed[$i], $maxmean[$i], $iter->{$k}), "\n";
            print $out_fh join("\t", '', 'MedMedK', 'MedMeaK', 'MaxMedK', 'MaxMeaK'), "\n" if $k == $K[$#K];
            print $out_fh join("\t", 'ALL', $medk->{'medmed'}, $medk->{'medmean'}, $medk->{'maxmed'}, $medk->{'maxmean'}), "\n" if $k == $K[$#K];
        
        }
        close $out_fh;
        $reps = $iter;
    }
    store $clsts, "$out_path/${dir}clsts";
    store $ma, "$out_path/${dir}ma";
    store $qtable, "$out_path/${dir}qtable";
    
    my (%pops, @pops, @aa);
        my $sum1 = $$sum[0];
        my $sum2 = $$sum[1];
        my $sum3 = $$sum[2];
        my $sum4 = $$sum[3];
        foreach(sort{$a <=> $b} keys %$sum1) {$pops{$sum1->{$_}}++; push @pops, $sum1->{$_};}
        
        @pops    = uniq(@pops); # original order.
        map {push @aa, $pops{$_};} @pops;
        my $a_   = scalar(keys %pops);
        my $b_   = scalar(@$sum2);
        my $c_   = scalar(@$sum3);
        @$sum2   = natsort @$sum2; # sort Naturally.
        open($out_fh, ">$out_path/${dir}sum.tsv") or die "$!";
        my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
        print $out_fh "#File generated at $ltime\n";
        print $out_fh "#Data format: ADMIXTURE or fastStructure\n#$a_ Populations(with each number): ". join(",", @aa), "\n";
        print $out_fh "#$b_ files (with each name):\n####". join("\n####", @$sum2), "\n";
        print $out_fh "#$c_ K: ".join(",", @$sum3), "\n";
        print $out_fh join("\t", '#No. of files', 'K', 'Individuals', 'Populations(Groups)'), "\n";
        print $out_fh join("\t", $b_, $c_, $sum4, $a_), "\n";
        close $out_fh;
    return ($ma, $ll, $reps);
}

sub calc_str {
    
    #
    #
    #
    my $files   = shift;
    my $in_path = shift;
    my $thred   = shift;
    my $dir     = shift; # name for the output.
    my $delta   = shift; # calculate deltaK.
    my $grp     = shift; # Group Option.
    my @thred   = @$thred;
    my ($clsts, $K, $file, $repss, $ma, $pop_flag, $sum, $qtable) = struct_parser::parse_struct_new($files, $in_path, $grp, $out_path);
    my @K = @{$K};
    $dir .= $dir ? '.' : '';
    if ($pop_flag) {
        foreach $thred (@thred) {
            my ($med, $medk, $iter) = struct_parser::calc_medk($clsts, $thred, $K);
            
            my @medmed  = @{$med->{'medmed'}};
            my @medmean = @{$med->{'medmean'}};
            my @maxmed  = @{$med->{'maxmed'}};
            my @maxmean = @{$med->{'maxmean'}};
            #
            # Output results....
            #
            #print header.
            open($out_fh, ">$out_path/${dir}MedK.$thred.tsv") or die "$!";
            my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
            print $out_fh "# File generated at $ltime\n";
            print $out_fh $medk_head;
            print $out_fh join("\t", 'K', 'MedMed', 'MedMean', 'MaxMed', 'MaxMean', 'Reps'), "\n";
            
            for (my $i=0; $i<@K; ++$i) {
                
                my $k = $K[$i];
                print $out_fh join("\t", $k, $medmed[$i], $medmean[$i], $maxmed[$i], $maxmean[$i], $iter->{$k}), "\n";
                print $out_fh join("\t", '', 'MedMedK', 'MedMeaK', 'MaxMedK', 'MaxMeaK'), "\n" if $k == $K[$#K];
                print $out_fh join("\t", 'ALL', $medk->{'medmed'}, $medk->{'medmean'}, $medk->{'maxmed'}, $medk->{'maxmean'}), "\n" if $k == $K[$#K];
            
            }
            close $out_fh;
            
        }
       
    }
    
    store $clsts, "$out_path/${dir}clsts";
    store $ma, "$out_path/${dir}ma";
    store $qtable, "$out_path/${dir}qtable";
    `mv $out_path/PopMap_for_admixture $out_path/${dir}pop.admixlabel`;
    
    # output sum stat.
    # 1:popmap. 2: number of files. 
    # 3:number of K. 4: number of individuals.
    my (%pops, @pops, @aa);
    my $sum1 = $$sum[0];
    my $sum2 = $$sum[1];
    my $sum3 = $$sum[2];
    my $sum4 = $$sum[3];
    foreach(sort{$a <=> $b} keys %$sum1) {$pops{$sum1->{$_}}++; push @pops, $sum1->{$_};}
    
    @pops    = uniq(@pops); # original order.
    map {push @aa, $pops{$_};} @pops;
    my $a_   = scalar(keys %pops);
    my $b_   = scalar(@$sum2);
    my $c_   = scalar(@$sum3);
    @$sum2   = natsort @$sum2; # sort Naturally.
    open($out_fh, ">$out_path/${dir}sum.tsv") or die "$!";
    my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
    print $out_fh "#File generated at $ltime\n";
    print $out_fh "#Data format: STRUCTURE\n#$a_ Populations(with each number): ". join(",", @aa), "\n";
    print $out_fh "#$b_ files (with each name):\n####". join("\n####", @$sum2), "\n";
    print $out_fh "#$c_ K: ".join(",", @$sum3), "\n";
    print $out_fh join("\t", '#No. of files', 'K', 'Individuals', 'Populations(Groups)'), "\n";
    print $out_fh join("\t", $b_, $c_, $sum4, $a_), "\n";
    close $out_fh;
    
    if ($delta) {
    
        #
        # Delta K
        #
        my ($delta, $fg) = struct_parser::calc_deltak($K, $repss);
        open($out_fh, ">$out_path/${dir}DeltaK.tsv") or die "$!";
        
        if ($fg == 0) {print $out_fh "## Warning!! Your files contain noncontiguous K or the replicates for each K are not enough. Better to check your files and use this result with caution.\n";} # warnings;
        my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
        print $out_fh "# File generated at $ltime\n";
        print $out_fh $delta_head;
        foreach my $k (@K) {
        
            my $a = $delta->{$k}->{'iter'};
            my $b = $delta->{$k}->{'estLnPk'}       ? sprintf "%.5f", $delta->{$k}->{'estLnPk'}: 'NA';
            my $c = $delta->{$k}->{'std'}           ? sprintf "%.5f", $delta->{$k}->{'std'}    :  0  ;
            my $d = $delta->{$k}->{'lnpk'}          ? sprintf "%.5f", $delta->{$k}->{'lnpk'}   : 'NA';
            my $e = $delta->{$k}->{'lnppk'}         ? sprintf "%.5f", $delta->{$k}->{'lnppk'}  : 'NA';
            my $f = $delta->{$k}->{'deltak'}        ? sprintf "%.5f", $delta->{$k}->{'deltak'} : 'NA';
        
            print $out_fh join("\t", $k, $a, $b, $c, $d, $e, $f), "\n";    
        
        }
        
        close $out_fh;
    }

    if ($parsimony) {
        # parsimony method
        my ($pi, $flg) = struct_parser::calc_pi($clsts, $log_prob);
        open($out_fh, ">$out_path/${dir}pi.tsv") or die "$!";
        my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
        print $out_fh "# File generated at $ltime\n";
        print $out_fh $pi_head;
        foreach my $k (@K) {

            my $a = $pi->{$k}->{'iter'};
            my $b = $pi->{$k}->{'nr'};
            my $c = $pi->{$k}->{'sps'};
            my $d = $pi->{$k}->{'sps_star'};
            my $e = $pi->{$k}->{'pi'};
            print $out_fh join("\t", $k, $a, $b, $c, $d, $e, $f), "\n";

        }

        close $out_fh;
    }

    return $ma; # return Q-matrix.
}

sub chooseK {
    #
    #
    #
    
    my $in_path  = shift;
    my $out_path = shift;
    my $out      = shift;
    my $ma       = shift;
    my $ll       = shift;
    $out .= $out ? '.' : '';
    my $bestK = struct_parser::choos_k($in_path, $ma);
    
    my (@ll, @cv);
    if ($ll) {
        @ll = sort {$ll->{$b}->{'ll'} <=> $ll->{$a}->{'ll'}} keys %{$ll} ;
        @cv = @ll && $ll->{$ll[0]}->{'cv'} ? sort {$ll->{$a}->{'cv'} <=> $ll->{$b}->{'cv'}} keys %{$ll} : ();
    }
    
    open(my $out_fh, ">$out_path/${out}chooseK") or die "$!";
    my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
    print $out_fh "# File generated at $ltime\n";
    print $out_fh "Model complexity that maximizes likelihood is $ll[0], likelihood is $ll->{$ll[0]}->{'ll'}\n" if @ll;
    print $out_fh "Model complexity that minimizes CV error is $cv[0], CV error is $ll->{$cv[0]}->{'cv'}\n" if @cv && $ll->{$cv[0]}->{'cv'} ne 'NA';
    print $out_fh "Model components used to explain structure in data is $bestK\n";
    close $out_fh;
    
}

sub pr_likelihood {
    #
    # print log likelihood, CV and deltaK if available.
    #
    my $ll       = shift;
    my $reps     = shift;
    my $out_path = shift;
    my $out      = shift; # out name.
    
    return 0 if not $ll; # No likelihood to print.
    
    my @iter = sort{$a<=>$b} values %$reps;
    my @K  = sort {$a <=> $b} keys %{$ll};
    my ($delta, $fg);
    if ($iter[0] >= 2) {
        # calculate deltak based on likelihood.
        ($delta, $fg) = struct_parser::calc_deltak(\@K, $ll, $reps);
        #undef $delta unless $fg;
    }
    
    # output results
    $out = $out ? $out . '.' : ''; 
    open(my $out_fh, ">$out_path/${out}ll.log") or die "$!";
    my $ltime = strftime "%Y-%m-%d %H:%M:%S %Z", localtime;
    
    if ($fg == 0) {print $out_fh "## Warning!! Your files contain noncontiguous K or the replicates for each K are not enough. " .
    "Better to check your files and use this result with caution.\n"}
    
    print $out_fh "# File generated at $ltime\n";
    print $out_fh join("\t", '#K', 'Reps', 'Likelihood', 'Likelihood std', 'CV errors', 'CV errors std', 'DeltaK'), "\n";
    
    foreach my $k (@K) {
        #
        # mean likelihood
        #
        my $a = $ll->{$k}->{'ll'}               ? sprintf "%.5f", $ll->{$k}->{'ll'}        : 'NA';
        my $b = $ll->{$k}->{'llstd'}            ? sprintf "%.5f", $ll->{$k}->{'llstd'}     :  0;
        my $c = $ll->{$k}->{'cv'}               ? sprintf "%.5f", $ll->{$k}->{'cv'}        : 'NA';
        my $d = $ll->{$k}->{'cvstd'}            ? sprintf "%.5f", $ll->{$k}->{'cvstd'}     :  0;
        my $e = $delta->{$k}->{'deltak'}        ? sprintf "%.5f", $delta->{$k}->{'deltak'} : 'NA';
        
        print $out_fh join("\t", $k, $reps->{$k}, $a, $b, $c, $d, $e), "\n";
        
    }
    close $out_fh;
    
    
}

sub parse_flst {
    
    #
    # get file list from multiple folders or different datasets.
    #
    my $in_path = shift;
    my $fmt     = shift;
    my $flag    = shift;
    
    my (@batches, @files, $flst);
    my $batch = 0;
    opendir(D, $in_path) or die "$!";
    my @dirs = readdir(D);
    foreach my $dir (@dirs) {
        next if $dir =~ /^\./;
        if ($flag) {
            #
            # only one dataset in one folder.
            #
            next if (-z "$in_path/$dir"); # skip zero files.
            if ($fmt eq 'admix') {
                next if $dir !~ /\.Q$|\.meanQ/;
                push @files, $dir;
            } elsif ($fmt eq 'struct') {
                next if $dir !~ /_f$/;
                push @files, $dir;
            } else {
                push @files, $dir;
            }
            $batch = 0;
            next;
        }
        if (-d "$in_path/$dir") {
            push @batches, $dir;
            $batch = 1;
        } else {
            next if (-z "$in_path/$dir"); # skip zero files.
            push @files, $dir;
            #$batch = 0;
        }
    }
    
    die "No files in this folder\n" if (@batches == 0 && @files == 0);
    if ($flag) {
        return \@files;
        next;
    }
    if ($batch == 1) {
        #
        # return batch folders.
        #
        return(\@batches, $batch);
    } else {
        
        if ($fmt eq 'struct') {
            #
            # structure files
            #
            foreach my $file (@files) {
                # name_XXX_f
                $file =~ /(.+)_(\w*\d+)_f/;
                my $name = $1;
                my $run  = $2;
                $flst->{'f'}->{$name}->{$run} = $file;
            }
            return($flst, $batch);
        } elsif ($fmt eq 'admix') {
            #
            # admixture files.
            #
            foreach my $file (@files) {
                # name.K.Q
                my ($name, $run);
                if ($file =~ /(.+)\.(\d+)\.Q$/) {
                    $name = $1;
                    $run  = $2;
                } elsif ($file =~ /(.+)\.(\d+)\.meanQ$/){
                    $name = $1;
                    $run  = $2;
                } else {
                    next;
                }
                $flst->{'q'}->{$name}->{$run} = $file;
            }
            return($flst, $batch);
        } else {
            #
            # other Q-matrix.
            # we can not read
            #
            return(\@files, $batch);
        }
    }

}
                
